### 锁

> 锁是用于管理不同事务对共享资源的并发访问

表锁和行锁的区别：

在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的

但是在并发性能上，表锁远低于行锁。

表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。

### Mysql Innodb 锁类型

* 共享锁 Shared Locks  （简称 S 锁，属于行锁）

* 排他锁 Exclusive Locks（简称 X 锁，属于行锁）

* 意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）

* 意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）

* 自增锁 AUTO-INC Locks

#### 共享锁（S）与排它锁 （X）

##### 共享锁

> 又称之为 读 锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；

加锁释放方式：



##### 排它锁

> 又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（此时其他事务要读取数据可从快照获取）

加锁释放方式：

##### InnoDB 行锁到底锁的是什么？

InnoDB的行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）

#### 意向共享锁(IS)和意向排他锁()

##### 意向共享锁

表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。

##### 意向排他锁

表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。

意向锁是InnoDB数据操作之前自动加的，不需要用户干预

这两个意向锁存在的意义是：

> 当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回该表不能启用表锁，提高了加锁的效率。



#### 行锁的算法

行锁锁的是索引上的索引项

只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）

###### 行锁的算法

- 临键锁 Next-Key locks

  当sql执行按照索引进行数据的检索时，查询条件为范围查找（between and < > 等等）并有数据命中，则测试SQL语句加上的锁为Next-Key locks,锁住索引的记录+区间，这个区间是左开右闭的

- 间隙锁 Gap : 当记录不存在时，临键锁退化成Gap

  在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（左开右开）

- 记录锁 Record Lock :唯一性索引 条件为精准匹配，退化成Record锁

  当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这是SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。

###### 行锁算法举例

**临键锁**

是InnoDB默认的行锁算法