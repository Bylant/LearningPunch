### 目标

* 掌握代理模式的应用场景和实现原理。 

* 了解静态代理和动态代理的区别。 

* 了解 CGLib 和 JDK Proxy 的根本区别。 

* 手写实现定义的动态代理。 

### 应用场景

在生活中，我们经常见到这样的场景，如：租房中介、售票黄牛、婚介媒婆、经纪人、 

事务代理、非侵入式日志监听等，这些都是代理模式的实际体现。

代理模式（`Proxy Pattern`）的定义也非常简单，是**指为其他对象提供一种代理，以控制对这个对象的访问**。 

代理对象在客服端和目标对象之间起到**中介**作用，代理模式属于**结构型设计模式**。

使用代理模式主要有两个目的：

* 保护目标对象

* 增强目标对象

下面我们来看一下代理模式的类结构图：

`Subject` 顶层接口

`RealSubject`  真实对象，也就是被代理对象

`Prxoxy` 代理对象

代理对象持有被代理对象的引用，客户端调用被代理对象方法，同事也调用被代理对象的方法，但是在代理对象前后在增加一些其他处理。

代理模式属于结构型模式，有静态代理和动态代理。

### 静态代理

显示声明被代理对象

> 三层架构就是一种典型的静态代理

 

### 动态代理

#### JDK 动态代理

`InvocationHandler` 

`Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterface(),this);`

字节码重组

jad 反编译

#### CGLIB 代理



### JDK Proxy 手写实现

1. 拿到被代理对象的引用，并且获取到它的所有的接口，反射获取；
2. JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类实现的所有接口；
3. 动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用；
4. 编译新生成的 Java 代码；
5. 重新加载到 JVM 中去运行。

以上过程就叫 **字节码重组**。