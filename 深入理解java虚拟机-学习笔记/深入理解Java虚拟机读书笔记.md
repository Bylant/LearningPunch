# 深入理解 Java 虚拟机读书笔记

## 第二章  Java 内存区域与内存溢出异常

### 运行时数据区

![图来自于《深入理解 Java 虚拟机 第 2 版》](assets/1552285007986.png)

#### 程序计数器

当前线程所执行的字节码的 **行号指示器**

每条线程都需要有一个独立的 程序计数器，各条线程之间计数器互不影响，属于**线程私有区域**

* 如果执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址

* 如果执行的是一个 Native 方法，计数器的值则为空（undefined）

#### Java 虚拟机栈

也是属于**线程私有区域**，生命周期与线程相同。

每个 Java 方法在执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

该区域有两种异常情况

* `StackOverflowError` ：线程请求的栈深度大于虚拟机所允许的深度 
* `OutOfMemoryError` ：虚拟机在自动扩展的时候请求不到足够的内存

#### 本地方法栈

与虚拟机栈发挥的作用类似，但是两者服务对象不同，本地方法栈为虚拟机使用到的 Native 方法服务，虚拟机栈为虚拟机执行的 Java 方法服务。

备注：有的虚拟机实现可以把二者合二为一

与虚拟机栈一样，该区域也存在两种异常情况，同上。

#### Java 堆

Heap 是 虚拟机所管理内存中最大的一块，此区域是被所有线程共享的一块内存区域，在虚拟机启动时创建。

此区域的唯一目的就是 **存放对象实例**，几乎所有的对象都在这里分配内存。

#### 方法区

此区域是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量等代码数据。

当方法区无法满足内存分配需求时，抛出 `OutOfMemoryError`异常。

##### 运行时常量池

方法区的一部分

### HotSpot 虚拟机对象探秘

#### 对象的创建

* 指针碰撞

* 空闲列表

#### 对象的内存布局

对象在内存中存储的布局可以分为 3 块区域：**对象头、实例数据和对齐填充**

## 第三章 垃圾收集器与内存分配策略

### 概述

说起垃圾回收我们需要思考三个问题：

* 哪些内存需要回收 ？
* 什么时候回收 ？
* 怎么回收 ？

如何判断对象是否存活？

#### 引用计数算法

为每个对象设置一个引用计数器，每当有一个地方引用该对象时，计数器值加 1 ，引用失效时，计数器值减 1，当计数器值变成 0 的时候就代表这个对象是不可能再被使用的，此时就代表该对象可以回收。

这种算法实现简单，效率也很高，但是同时也会存在一个问题，那就是当两个对象相互循环引用的时候，哪怕这两个对象以后再也不会用到，但是因为相互引用的问题，这两个对象的引用计数器始终不为 0，导致 GC 无法回收他们。

也正是因为这个问题，所以很多主流虚拟机厂商都没有选择这种回收计数算法。而更多的使用的是下文将要介绍的**可达性分析算法**。

#### 可达性分析算法

该算法的原理是：以 `GC Roots` 的对象作为起始点，然后以该节点为基准开始向下搜索，搜索过程中搜索路径我们称之为**引用链**，当一个对象到 `GC Roots` 没有任何引用链连接的时候，说明该对象是不可用的。

注意：可以作为 `GC Roots` 对象的包括以下几种

* 虚拟机栈（本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI （Native 方法）引用的对象

我们需要注意一点，哪就是即使通过可达性分析中不可达的对象也不是必须要回收的。

一个对象在真正被回收之前，需要经历两次标记过程：

>如果对象在进行可达性分析之后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆盖 finalize() 方法 或者 finalize() 方法已经被虚拟机调用过，这两种情况下虚拟机都认为此时没有必要执行垃圾回收。
>
>![1552455795999](assets/1552455795999.png)
>
>个时候还没有逃脱，哪基本上它就真的被回收了。

##### 四种引用方式

根据引用强度（从上至下依次减弱）可依次划分为：

* 强引用 `Strong Reference`

* 软引用 `Weak Reference`

* 弱引用 `Phantom Reference`

* 虚引用 `Soft Reference`

![图片内容来自于《深入理解 Java 虚拟机》第二版 第 1220 页 ](assets/1552455339618.png)

### 垃圾收集算法

#### 标记-清楚算法

**缺点**：

* 效率问题：标记和清楚这两个过程效率都不太高
* 空间问题：标记清楚之后会产生大量不连续的内存碎片

#### 复制算法

为了解决效率问题，复制算法出现了，它将可用内存分成了大小相等的两块，每次只使用其中的一块，当其中一块的内存用完了之后就将这个区域还存活的对象全部复制到另一块内存上去，然后把直接把这块内存区域全部回收掉。

这种分配方式也不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存就可以，实现简单，运行高效。

**缺点**：浪费了足足一半的内存区域，内存利用率只有 50%，代价太高昂。

哪么怎么样改善这种情况呢？

哪就是在划分内存空间的时候并不是按照 1:1 来划分，而是按照 Eden区域 ：S0 区域 ： S1 区域 为 8：1：1 的比例，每次在进行复制的时候都是选择把 Eden 区域和 S0 区域的存活对象复制到 S1 区域，这样一来整个内存空间的利用率就会达到 90%。

注意：在上述条件下，一旦 S1 区域空间不足，将会依赖老年代进行分配担保，就是说会把部分对象放到老年代。

#### 标记-整理算法

复制算法如果在对象存活率较高的时候就需要进行很多的复制操作，效率将会更低，除此之外，还需要有老年代的分配担保，因此对于老年代的回收一般都不会选择这种算法。

老年代主要是长期存活的对象或者比较大的对象，针对这种情况，又提出了标记-整理算法，标记过程和上述的标记-清楚类似，但是之后的步骤中，并不是直接对可回收对象进行回收，而是让所有存活对象都向一边移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

因为每个对象的生命周期不一致，所以经常把 Java 堆分为新生代和老年代，所以就提出了一种分代收集算法。

新生代中，每次垃圾回收时都有很多对象死去，只要少数存活，此时可以选择**复制算法**；

老年代中，对象一般都是存活率高、没有额外空间对它进行分配担保，则选择**标记-清理**或者**标记-整理**算法。

### 垃圾收集器

#### Serial 收集器

单线程收集器 进行垃圾收集时，其他的工作线程必须停止等待他进行垃圾回收。

* 运行在 Client 模式下的虚拟机首选的垃圾收集器

**优点**

简单高效

#### ParNew 收集器

是 Serial 收集器的多线程版本

* 运行在 Server 模式下的虚拟机中首选的新生代收集器。

#### CMS 收集器 （Concurrent Mark Sweep）

并发收集、低停顿

* 一种以获取**最短回收停顿时间**为目标的收集器。

* 基于 **标记-清楚** 算法

* 回收过程：

  * 初始标记

  * 并发标记

  * 重新标记

  * 并发回收

    其中初始标记和重新标记还是需要 Stop The World,初始标记只标记 **GC Roots 能直接关联到的对象**，速度很快；

    并发标记阶段：GCRoot 重新 GC RootsTracing 的过程；

    重新标记阶段：修正并发标记期间因用户程序继续运作而导致标记产生变动的哪一部分对象的标记记录，比初始标记耗时长，但远小于并发标记时间。

    整个过程耗时最长的是 并发标记 和并发清楚两个阶段，但是这两个阶段又和用户线程可以一起工作，从而总体而言，我们认为 CMS 收集器是和用户线程并发执行的。

* 缺点：

  * 对 CPU 资源敏感

    在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低。

    CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4

    P.S.意味着四个以上 CPU 的情况下，需要占用 25 % 的 CPU 资源。

  * 无法处理浮动垃圾

    可能会出现 Concurrent Mode Failure 失败而导致另一次 Full GC 的产生。

    因为 CMS 并发清理阶段用户线程依然在运行，程序运行就自然会有不断的垃圾产生，但是因为这一部分垃圾产生在标记过程之后，CMS 收集线程无法处理掉他们，只能等待下一次 GC 时进行标记清楚，这一部分垃圾称作 浮动垃圾。

    1.5 默认设置下，老年代占用超过 65 % 便会被激活 CMS收集器

    1.6 默认设置下，老年代占用超过 92 % 便会被激活 CMS收集器

    但是随着预留空间的减少，就有可能出现 Concurrent Mode Failure,此时需要启动备用预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，此时停顿时间陡增。

  * 基于 标记-清楚 算法，所以会产生大量的空间碎片

#### G1 收集器

Garbage-First  面向服务端应用的垃圾收集器。可以替换掉 CMS 收集器。

##### 特点

并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短停顿时间。

分代收集

空间整合：使用 标记-整理 算法

可预测的停顿：可预测停顿时间的模型

G1 之前其他收集器收集范围是整个新生代或者老年代，但是 G1 不是这样的。G1 把整个内存区域划分为很多大小相等的独立区域（Region），虽然还是保留有新生代和老年代的说法，但是新生代和老年代不再是物理隔离的，他们都是一部分 Region 的集合。

G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

但是问题在于 Region 不可能是孤立的，一个对象分配在某个 Region 中，它并非只能被本 Region 中的其他对象引用，而是可以与整个 Java 堆任意的对象发生引用关系。这样一来使用可达性判断对象是否存活的时候，就需要扫描整个 Java 堆才能保证准确性。

Remembered Set 可以避免扫描全堆：每个 Region 对应一个 Remembered Set

虚拟机发现程序在对 Reference 类型的对象进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否位于不同的 Region 中（分代收集时则是判断老年代中的对象是否引用了新生代对象），如果是，则通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。

##### 大致收集过程

* 初始标记
* 并发标记
* 最终标记
* 筛选回收

#### 理解 GC 日志

垃圾回收的停顿类型 

垃圾回收发生的时间

垃圾回收发生的区域

GC 前该区域已使用的容量 ---> GC 后该区域已使用的容量

GC 前 Java 堆已使用容量   ---> GC 后 Java 堆已使用容量

该内存区域 GC 本次占用的总时间

* user ：用户态 CPU 消耗时间
* sys ：内核态 CPU 消耗时间
* real : 墙钟时间 （非计算耗时，如 IO 等待，等待线程阻塞等）

#### 内存分配与回收策略

* 优先在 Eden 区域分配，当 Eden 空间不足时，发生一次 MinorGC

  ```java
  public class MinorGC {
  
      private static final int _1MB = 1024 * 1024;
  
      /**
       * JVM 参 数：-verbose:gc-Xms20M-Xmx20M-Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
       
       上述参数意义：
       限制了 Java 堆大小是 20M 不可扩展 其中 10M 分给新生代
       新生代和 Survivor 区空间比例是 8 ：1
       
       新生代率先分配 1 2 3 三个对象 
       */
      public static void testAllocation() {
          byte[] allocation1, allocation2, allocation3, allocation4;
          allocation1 = new byte[2 * _1MB];
          allocation2 = new byte[2 * _1MB];
          allocation3 = new byte[2 * _1MB];
          // 出 现 一 次 Minor GC 因为新生代已经有 6M 空间被占用 剩余空间不足以分配 4 变量，从而开始 MinorGC，但是由于 1 2 3 三个变量都无法放入 Survivor 区，因为 Survivor 区域大小只有 1 M，因此通过分配担保会把 1 2 3 三个变量提前转移到老年代中。
          // 转移过去之后 4 变量会被分配在 Eden 区
          // GC 之后的最终结果就是 Eden 占用 4M Survivor 空闲 老年代被占用 6M
          allocation4 = new byte[4 * _1MB];
      }
  
      public static void main(String[] args) {
          System.out.println("Start");
          testAllocation();
          System.out.println("Done");
      }
  }
  ```

* 大对象直接进入老年代

  大对象是指需要大量连续内存空间的 Java 对象

  ```
  -XX:PretenureSizeThreshold=3145728 // 指定超过一定大小的对象直接进入老年代
  ```

* 长期存活的对象进入老年代

  每个对象都拥有一个年龄计数器，如果对象在 Eden 去出生并经过一次 MinorGC 后依然存活，并且能被 Survivor 容纳的话，将移动到 Survivor 空间中，并且对象年龄设置为 1

  此后对象每在 Survivor 区中熬过一次 MinorGC，年龄就增加 1 岁

  年龄增加到一定程度（默认 15 岁），就将会被晋升到老年代中，这个值可以通过如下参数调整

  ```
  -XX:PretenureSizeThreshold=3145728
  ```

* 动态对象年龄判断

  

* 空间分配担保