> 本系列文章参考内容为 闪电侠 的掘金小册
>
> 地址 ：[Netty入门与实战：仿写微信IM即时通信系统](https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521)

**指令数据**包分为 **指令**和**数据**

### 传统的 Socket IO 编程

1. 线程资源受限：同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起；
2. 线程切换效率低下：单机 CPU 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降；
3. IO 读写面向字节。

### NIO 编程

NIO 编程模型很好的解决了上述两个问题。

#### 线程资源受限问题

NIO 编程模型中，新来的一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责。

IO 模型中，每个连接都会创建一个新线程，对应一个 while 循环，死循环的目的就是不断检测这条连接上是否有数据可以读，大多数情况下，同一时刻只有少量的连接有数据可读，因此，很多个 while 死循环都白白浪费掉了，因为读不出啥数据。

NIO 模型中，把这么多的 while 死循环变成了一个死循环，这个死循环由一个线程控制：

> 一条连接来了之后，现在不创建一个 while 死循环去监听是否有数据可读了，而是直接把这条连接注册到 selector 上，然后，通过检查这个 selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明 IO 与 NIO 的区别。

#### 线程切换效率低下

NIO 模型中线程数量大大降低，线程切换效率大幅度提高了。

#### IO 读写面向字节流

IO 读写是面向字节流的，一次只能从流中读取一个或者多个字节，并且读完之后无法再次读取，需要自己缓存数据，而 NIO 的读写是面向 Buffer 的，可以随意读取里边的任何一个字节数据，也不需要自己缓存数据，我们只需要移动读写指针即可。



------

> 
>
> JDK 的 NIO 犹如带刺的玫瑰，虽然美好，让人向往，但是使用不当会让你抓耳挠腮，痛不欲生，正因为如此，Netty 横空出世！

### Netty 是什么

Netty 封装了 JDK 的 NIO，让使用者用的更爽，不用再写一大段复杂的代码了。

> Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。

1. JDK 自带的 NIO 需要了解的概念田铎，编程复杂；

2. Netty 底层 IO 模型随意切换，只需要修改参数，Netty 可以直接从 NIO 模型变身为 IO 模型；

3. Netty 自带的拆包解包、异常检测等机制可以让使用者从 NIO 繁重的细节中脱离出来，程序员只需要关注业务逻辑；

4. Netty 解决了 JDK 的很多空轮询在内的 Bug；

5. Netty 底层对线程、selector 做了很多细小的优化，精心设计的 reactor 线程模型可以做到非常高效的并发处理；

6. 自带各种协议栈；

7. 社区活跃；

8. Netty 已经经历各大 RPC 框架、消息中间件、分布式通信中间件线上的广泛验证，健壮性无比强大。

   