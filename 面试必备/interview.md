充电业务流程

用户侧

用户名密码登录手机 APP

1. 扫描二维码查找充电桩

   获取充电桩编码、运营商等信息，并上送充电桩信息

2. 用户认证服务

   上送平台认证信息

   返回平台认证结果信息

充换电服务平台

3. 设备认证服务

   查询充电基础设施的可用状态

   设备检测

   返回认证处理结果

4. 业务策略服务（可选）

   查询计费信息，主要是提供查询业务策略接口

5. 充电启动服务

   发送指令到充电基础设施，并返回启动结果给调用方

6. 充电监控服务（可选）

   充电基础设施变化状态的查询或推送，主要包括推送充电状态接口和查询充电状态接口

7. 充电停止服务（可选）

   停止充电指令并返回停止充电结果

8. 充电订单服务

   推送订单信息，启动充电成功则建立订单

9. 订单对账服务

   



### 为什么使用消息队列？

#### 优点

##### 解耦

多个系统调用，可以使用将数据发送到消息队列中，然后其他系统直接在消息队列消费

##### 削峰

一般 MySQL 扛到每秒 2k 个请求就差不多，超过这个数量 MySQL 就可能会死，进而导致系统崩溃。

##### 异步

#### 缺点

##### 系统可用性降低

引入外部系统越多，越容易挂掉。

###### 如何保证消息队列的高可用？

以 RabbitMQ 为例，RabbitMQ 有三种模式：

* 单机模式（适合本地做 demo）

  生产没人用单机模式

* 普通集群模式（无高可用）

  多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息）。消费的时候，实际上如果连接到了另外一个实例，哪么那个实例会从 queue 所在实例上拉取数据过来。

  **缺点**：MQ 集群内部可能产生大量的数据传输；可用性无保障，queue 所在节点宕机，数据就丢了（如果开启消息持久化的话消息不一定丢，但是必须等这个实例恢复了，才可以继续从这个 queue 拉取数据）。

  这个方案的好处是可以提高吞吐量，就是说让集群中多个节点来服务某个 queue 的读写操作。

* 镜像集群模式（高可用性）

  在镜像集群模式下，你创建的 queue，无论是元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思，每次写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。

  如何开启 ？

  增加一个 镜像集群模式的策略，指定的时候可以要求数据同步到所有节点，也可以要求同步到指定数量的节点。

  好处在于任何一个机器宕机，其他机器（节点）还是完整包含了这个 queue 的数据，别的 consumer 都可以到其他节点上去消费数据。

  坏处在于这么玩不是分布式的，没有扩展性可言，一旦某个 queue 负载很重，需要加机器，新增的机器也包含了这个 queue 的所有数据，并**没有办法线性扩展**你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了。



Kafka 的高可用性

Kafka 的结构：由多个 broker 组成，每个 broker 是一个节点，你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。

这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就存放一部分数据。

读数据

某个 broker 宕机，因为这个 broker 上面的 partition 在其他机器上都是有副本的，如果这个宕机的 broker 上面有个 partition 的 leader，哪么此时会从 follwer 中重新选举一个新的 leader 出来，大家继续读写哪个新的 leader 即可。

写数据

生产者只写 leader，然后 leader 负责将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 Pull 数据，一旦多有 follower 数据同步好了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。

消费的时候，还是只会从 leader 读，只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者消费到。

##### 系统复杂度提高

###### 如何保证消息不重复消费或者说如何保证消息消费的幂等性？

kafka 消息重复消费的一些情况

直接 kill 进程再重启，会导致 consumer 有些消息处理了，但是没来得及提交 offset ，这样重启之后就会导致有些消息会再次消费一次。（Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，**每隔一段时间**（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。）

结合具体业务来思考：

1. 比如往数据库写库，可以先根据主键查一下，如果数据已经存在了，就不进行插入，直接 update 一下

2. 比如写 redis ，不会存在这个问题，每次都是 set ，天然幂等

3. 更复杂的场景，可以让生产者发送数据的时候，给数据里边加一个全局唯一的 id，类似订单 id 之类的东西，然后到这里消费到了之后，先根据这个 id 去 比如 redis 里查一下，之前是否消费过？

   如果没有消费过，就直接处理，然后这个 id 写 redis，

   如果消费过了，哪就直接丢弃

4. 基于数据库的唯一键来保证重复数据不会重复插入多条等等

###### 如何保证消息的可靠性传输？或者说如何处理消息丢失的问题？

数据丢失可能出现在生产者、MQ以及消费者中

**以 RabbitMQ 为例**：

丢失消息分三种情况

1. 生产者在消息传入过程中丢失

   生产者丢失消息的情况（网络原因等），此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务 channel.txSelect，然后发送消息，如果消息没有发送成功被 RabbitMQ 接收到，哪么生产者会受到异常报错，此时就可以回滚事务 channel.txRollback，然后重试发送消息，反之如果收到了消息，哪么可以提交事务 channel.txCommit。

   但是一旦开启事务机制，则会严重影响性能，吞吐量会大幅下降。

   因此一般来说，确保写消息不丢失，可以开启 confirm 模式，在生产者哪里设置开启 confirm 模式之后，每次写消息都会分配一个唯一的 id，如果写入成功，RabbitMQ 会回传一个 ack 消息。

   如果没有处理这个消息，会回调你的一个 nack 接口，告诉你接受消息失败，你可以重试。

   以上两种机制：

   事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后哪个消息 RabbitMQ 接受了之后会异步回调你的一个接口通知你这个消息接受到了。

   所以一般 RabbitMQ 为了避免生产者丢失数据，都是采用 confirm 机制。 

2. RabbitMQ 收到消息，暂存在内存中，还没消费，自己挂掉了，内存中的数据搞丢了

   开启 RabbitMQ 的持久化，消息写入之后持久化到磁盘，设置持久化的步骤：

   * 创建 queue 的时候将其设置为持久化，这样可以保证 RabbitMQ 持久化 queue 的元数据，但是不会持久化 queue 里的数据
   * 发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时消息会被持久化磁盘上

3. 消费者消费到了这个消息，但是还没来得及处理，就挂了，RabbitMQ 以为消息已经被处理

   利用 RabbitMQ 提供的 ack 机制，首先关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用，然后每次在自己代码处理完之后，再在程序里 ack 一把，这样的话如果你还没处理完就不会出现 ack ，哪么 RabbitMQ 也会认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢失的。

**以 Kafka 为例**

丢失数据同样有三种情况

**消费端丢了数据**：唯一可能导致消费端丢失数据的情况，就是说你消费到了这个消息，然后消费者哪边自动提交了 offset，让 kafka 以为你已经消费到了这个消息，但其实你才刚准备处理这个消息，还没处理完你就挂了，此时这条消息就会丢失。

此时我们需要关闭自动提交 offset，在处理结束之后手动提交 offset，就可以保证数据不丢失。（但是也会有一种情况：kafka消费者消费到了之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offsetr，此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了）

**Kafka 丢了数据**：这种情况比较常见，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。此时要是其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成为 Leader 之后，就会丢了一些数据。

此时一般需要设置以下四个参数：

* topic 设置 replication.factor 参数，这个参数大于 1，要求每个 partition 必须 至少有 2 个副本
* 在 Kafka 端设置 min.insync.replicas 参数，这个参数大于 1，要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队。
* 在 producer 端设置 acks=all : 这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了（这样设置之后生产者肯定不会丢失数据）
* 在 producer 端设置 retries=MAX : 这个是要求一旦写入失败，就无线重试。

以上配置可以保证至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。

##### 一致性问题



#### 消息队列对比

![消息队列优缺点对比](http://images.zhoudl.top/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94.png)

一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；

不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 [Apache](https://github.com/apache/rocketmq)，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。

所以**中小型公司**，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；**大型公司**，基础架构研发实力较强，用 RocketMQ 是很好的选择。

如果是**大数据领域**的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。

##### 如何保证消息的顺序性？

先理解一下顺序会错乱的场景

##### RabbitMQ 中

一个 queue，多个 consumer，比如生产者向 RabbitMQ 里发送了三条数据，顺序依次是  data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 里消费者三条数据中的一条，结果消费者 2 线执行完操作，把 data2 存入数据库，然后是 data1/data3，这样就会明显造成数据错乱。

##### Kafka 中

比如说我们创建了一个 topic，有三个 partition。生产者在写数据的时候，其实可以指定一个 key，比如说我们注定了某个订单 id 作为 key，哪么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。

消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。

接着，我们在消费者里可能会搞多个线程来并发处理消息，因为如果消费者是单线程消费处理，而处理比较耗时的话，吞吐量太低了，此时因为是多线程跑所以顺序很可能就乱掉了。

##### 解决方案

###### RabbitMQ

* 拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，会麻烦一点；

* 或者就一个 queue 但是对应多个 consumer，然后这个 consumer 内部用内存队列做排队，最后分发给底层不同的 worker 来处理。

###### Kafka

* 一个 topic，一个 partition，一个 consumer，内部单线程消费，但是单线程吞吐量太低，一般不会用这个
* 写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue，然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保住顺序性。



#### 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？





-----------------

充电桩系统

用户发起充电，发起充电这个过程

需要传输的服务有：

充电服务

订单服务