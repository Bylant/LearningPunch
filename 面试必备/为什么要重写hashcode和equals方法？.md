### 引言

以前面试的时候被人问到过这样一个问题：

> 你有没有重写过 hashcode 方法？

心里想着我没事重写哪玩意干啥，能不写就不写。嘴上当然没敢这么说，只能略表遗憾的说抱歉，我没写过。

我撇了面试官一眼，明显看到他对这个回答不满意，但是这已经触及到我的知识盲点了，我也很惭愧，可是确实没有重写过。

他又问到另外一个问题：

> 你在用 HashMap 的时候，键（Key）部分，有没有放过自定义对象？

我说我放过，很自信的说我放过（其实我忘了我有没有放过），但是不能怂啊，第一个都不会了，第二个再说不会哪不是直接拜拜要走人了吗？

面试官狡猾的笑了，说是你既然没有重写过 hashcode 方法，你怎么把自定义对象放进去的？

我勒个去，原来你在这等着我呢，没想到这还是个连环炮，惹不起惹不起，认怂三连



不会就学，不懂就问，这一直都是咱程序猿优秀的素养，今天就干脆从 Hash 表学起，讲述 HashMap 的存数据规则，由此搞定上述问题的答案。

###  通过 Hash 算法来了解 HashMap 对象的高效性

我们先复习数据结构里的一个知识点：

> 在一个长度为 n（假设是10000）的线性表（假设是 ArrayList）里，存放着无序的数字；如果我们要找一个指定的数字，就不得不通过从头到尾依次遍历来查找，这样的平均查找次数是 n 除以 2（这里是5000）。

我们再来观察 Hash 表（这里的 Hash 表纯粹是数据结构上的概念，和 Java 无关）。它的平均查找次数接近于 1，代价相当小，关键是在 Hash 表里，存放在其中的数据和它的存储位置是用 Hash 函数关联的。

我们假设一个 Hash 函数是 x*x%5。当然实际情况里不可能用这么简单的 Hash 函数，我们这里纯粹为了说明方便，而 Hash 表是一个长度是 11 的线性表。如果我们要把 6 放入其中，那么我们首先会对 6 用 Hash 函数计算一下，结果是 1，所以我们就把 6 放入到索引号是 1 这个位置。同样如果我们要放数字 7，经过 Hash 函数计算，7的结果是 4，那么它将被放入索引是 4 的这个位置。这个效果如下图所示。

![img](https://img2018.cnblogs.com/blog/1226172/201903/1226172-20190305064457991-1201744465.png)

这样做的好处非常明显。比如我们要从中找 6 这个元素，我们可以先通过 Hash 函数计算 6 的索引位置，然后直接从 1 号索引里找到它了。

不过我们会遇到**Hash值冲突**这个问题。比如经过 Hash 函数计算后，7 和 8 会有相同的 Hash 值，对此 Java 的HashMap 对象采用的是**链地址法**的解决方案。

效果如下图所示。

 ![img](https://img2018.cnblogs.com/blog/1226172/201903/1226172-20190305064538690-1499368989.png)

具体的做法是，为所有 Hash 值是 i 的对象建立一个同义词链表。假设我们在放入 8 的时候，发现 4 号位置已经被占，那么就会新建一个链表结点放入 8。同样，如果我们要找 8，那么发现 4 号索引里不是 8，那会沿着链表依次查找。

虽然我们还是无法彻底避免 Hash 值冲突的问题，但是 Hash 函数设计合理，仍能保证同义词链表的长度被控制在一个合理的范围里。这里讲的理论知识并非无的放矢，大家能在后文里清晰地了解到重写 hashCode 方法的重要性。

### 2 为什么要重写equals和hashCode方

当我们用 HashMap 存入自定义的类时，如果不重写这个自定义类的 equals 和 hashCode 方法，得到的结果会和我们预期的不一样。我们来看 WithoutHashCode.java 这个例子。

在其中的第 2 到第 18 行，我们定义了一个 Key 类；在其中的第 3 行定义了唯一的一个属性 id。当前我们先注释掉第 9 行的 equals 方法和第 16 行的 hashCode 方法。    

```java
import java.util.HashMap;
class Key {
       private Integer id;
       public Integer getId() {
		return id;
	   }
       public Key(Integer id) {
		this.id = id;
	   }
//故意先注释掉equals和hashCode方法
// public boolean equals(Object o) {
//    	if (o == null || !(o instanceof Key)){
//			return false; 
//		} else {
//       return this.getId().equals(((Key) o).getId());
//		}
// }

//  public int hashCode() {
//  	return id.hashCode(); 
//	}
//}

public class WithoutHashCode {
    public static void main(String[] args) {
        Key k1 = new Key(1);
        Key k2 = new Key(1);
        HashMap<Key,String> hm = new HashMap<Key,String>();
        hm.put(k1, "Key with id is 1");    
        System.out.println(hm.get(k2));    
    }
}
```

在 main 函数里，我们定义了两个 Key 对象，它们的 id 都是 1，就好比它们是两把相同的都能打开同一扇门的钥匙。

然后我们通过泛型创建了一个 HashMap 对象。它的键部分可以存放 Key 类型的对象，值部分可以存储 String 类型的对象。

紧接着我们通过 put 方法把 k1 和一串字符放入到 hm 里； 然后我们想用 k2 去从 HashMap 里得到值；这就好比我们想用 k1 这把钥匙来锁门，用 k2 来开门。

这是符合逻辑的，但从当前结果看，打印出的返回结果不是我们想象中的那个字符串，而是 null。

原因有两个—没有重写：

* 没有重写 hashCode 方法
* 没有重写 equals 方法。

当我们往 HashMap 里放 k1 时，首先会调用 Key 这个类的 hashCode 方法计算它的 hash 值，随后把 k1 放入 hash 值所指引的内存位置。

关键是我们没有在 Key 里定义 hashCode 方法。这里调用的仍是 Object 类的 hashCode 方法（所有的类都是Object 的子类），而 Object 类的 hashCode 方法返回的 hash 值其实是 k1 对象的内存地址（假设是 1000）。

​    ![img](https://img2018.cnblogs.com/blog/1226172/201903/1226172-20190305064746385-445045.png)

如果我们随后是调用 hm.get(k1)，那么我们会再次调用 hashCode 方法（还是返回 k1 的地址 1000），随后根据得到的 hash 值，能很快地找到 k1。

但我们这里的代码是 hm.get(k2)，当我们调用Object类的 hashCode方法（因为 Key 里没定义）计算 k2 的 hash值时，其实得到的是 k2 的内存地址（假设是 2000）。由于 k1 和 k2 是两个不同的对象，所以它们的内存地址一定不会相同，也就是说它们的 hash 值一定不同，这就是我们无法用 k2 的hash值去拿 k1 的原因。

当我们把代码中对 hashCode 方法的注释去掉后，会发现它是返回 id 属性的 hashCode值，这里 k1 和 k2 的 id 都是 1,所以它们的 hash 值是相等的。

我们再来更正一下存 k1 和 取k2 的动作。存 k1 时，是根据它 id 的 hash 值，假设这里是 100，把 k1 对象放入到对应的位置。而取 k2 时，是先计算它的 hash 值（由于 k2 的 id 也是 1，这个值也是 100），随后到这个位置去找。

但结果会出乎我们意料：明明 100 号位置已经有 k1，但打印输出结果依然是 null。其原因就是没有重写 Key 对象的 equals 方法。

HashMap 是用链地址法来处理冲突，也就是说，在 100 号位置上，有可能存在着多个用链表形式存储的对象。它们通过 hashCode 方法返回的 hash 值都是 100。

![img](https://img2018.cnblogs.com/blog/1226172/201903/1226172-20190305064916326-355335633.png)

当我们通过 k2 的 hashCode 到 100 号位置查找时，确实会得到 k1。但 k1 有可能仅仅是和 k2 具有相同的 hash值，但未必和 k2 相等（k1 和 k2 两把钥匙未必能开同一扇门），这个时候，就需要调用 Key 对象的 equals 方法来判断两者是否相等了。

由于我们在 Key 对象里没有定义 equals 方法，系统就不得不调用 Object 类的 equals 方法。由于 Object 的固有方法是根据两个对象的内存地址来判断，所以 k1 和 k2 一定不会相等，这就是为什么通过 hm.get(k2) 依然得到null 的原因。

为了解决这个问题，我们需要打开上述代码中注释掉的部分。在这个方法里，只要两个对象都是 Key 类型，而且它们的 id 相等，它们就相等。

### 对面试问题的说明

由于在项目里经常会用到 HashMap，所以我在面试的时候一定会问这个问题∶你有没有重写过 hashCode 方法？你在使用 HashMap 时有没有重写 hashCode 和 equals 方法？你是怎么写的？

根据问下来的结果，我发现初级程序员对这个知识点普遍没掌握好。重申一下，如果大家要在 HashMap 的“键”部分存放自定义的对象，一定要在这个对象里用自己的 equals 和 hashCode 方法来覆盖 Object 里的同名方法。 